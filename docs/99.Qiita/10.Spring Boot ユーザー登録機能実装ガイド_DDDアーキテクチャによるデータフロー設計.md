# Spring Boot ユーザー登録機能実装ガイド: DDD アーキテクチャによるデータフロー設計

## はじめに

Spring Boot でユーザー登録機能を実装する際、「どのような順序で実装すべきか？」「データはどのように流れるべきか？」という疑問を持ったことはありませんか？

この記事では、DDD（ドメイン駆動設計）のアーキテクチャに基づいて、実際のユーザー登録機能を段階的に実装する過程とデータフローを解説します。

## 🎯 実装目標

```java
@PostMapping("/register")
public ResponseEntity<UserRegisteredResult> register(@RequestBody RegisterUserCommand command) {
    UserRegisteredResult result = registerUserService.register(command);
    return ResponseEntity.ok(result);
}
```

この API エンドポイントを完成させるまでの全工程を追跡します。

## 🏗️ アーキテクチャ概要

### レイヤー構成

```
┌─────────────────┐
│   API 層        │ ← Controller (HTTPレスポンス)
├─────────────────┤
│ Application 層  │ ← Service (ビジネスロジック)
├─────────────────┤
│  Domain 層      │ ← Entity, ValueObject (ドメインルール)
├─────────────────┤
│Infrastructure層 │ ← Repository (データ永続化)
└─────────────────┘
```

### データフロー

```
HTTP Request → Command → Service → Domain → Repository → Database
                ↓
HTTP Response ← DTO ← Service ← Domain ← Repository ← Database
```

## 📋 実装手順とデータフロー

### Phase 1: 入力データ設計 (Command パターン)

#### 1-1. RegisterUserCommand の実装

```java
public class RegisterUserCommand {
    @NotNull @Email
    private String email;

    @NotNull @Size(min = 8, max = 100)
    private String password;

    @NotNull @Pattern(regexp = "^[a-zA-Z0-9_-]+$")
    private String username;

    // デフォルトコンストラクタ（Jackson用）
    public RegisterUserCommand() {}

    // ドメインオブジェクト変換メソッド
    public Email toEmail() { return new Email(this.email); }
    public Username toUsername() { return new Username(this.username); }
}
```

**ポイント:**

- JSON → Java オブジェクト変換のためデフォルトコンストラクタが必須
- バリデーションアノテーションで入力チェック
- ドメイン値オブジェクトへの変換メソッド提供

#### データフロー（入力）

```
HTTP JSON Request → Jackson → RegisterUserCommand
```

### Phase 2: 出力データ設計 (DTO パターン)

#### 2-1. UserRegisteredResult の実装

```java
public class UserRegisteredResult {
    private Long userId;
    private String email;
    private String username;
    private LocalDateTime createdAt;

    // デフォルトコンストラクタ（Jackson用）
    public UserRegisteredResult() {}

    // ドメインオブジェクト変換ファクトリメソッド
    public static UserRegisteredResult from(User user) {
        return new UserRegisteredResult(
            user.getId(),
            user.getEmail().getValue(),
            user.getUsername().getValue(),
            user.getCreatedAt().atZone(ZoneId.systemDefault()).toLocalDateTime()
        );
    }
}
```

**ポイント:**

- セキュリティ: パスワードハッシュは含まない
- ファクトリメソッド: ドメインオブジェクトからの変換
- 時刻変換: Instant → LocalDateTime（API 用）

#### データフロー（出力）

```
User Domain Object → UserRegisteredResult → Jackson → HTTP JSON Response
```

### Phase 3: Service 層実装

#### 3-1. RegisterUserService の実装

```java
@Service
@Transactional
public class RegisterUserService {
    private final UserRepository userRepository;

    public UserRegisteredResult register(RegisterUserCommand command) {
        // 1. コマンドからドメイン値オブジェクトに変換
        Email email = command.toEmail();
        Username username = command.toUsername();

        // 2. メールアドレス重複チェック
        Optional<User> existingUserByEmail = userRepository.findByEmail(email);
        if(existingUserByEmail.isPresent()){
            throw new DuplicateEmailException(email.getValue());
        }

        // 3. ユーザー名重複チェック
        Optional<User> existingUserByUsername = userRepository.findByUsername(username);
        if(existingUserByUsername.isPresent()){
            throw new DuplicateUsernameException(username.getValue());
        }

        // 4. パスワードハッシュ化（PasswordHashコンストラクタ内で自動実行）
        PasswordHash passwordHash = new PasswordHash(command.getPassword());

        // 5. Userドメインモデル生成（ファクトリメソッド使用）
        User newUser = User.register(email, username, passwordHash);

        // 6. データベースに永続化（IDが自動採番される）
        User savedUser = userRepository.save(newUser);

        // 7. ドメインモデルをDTOに変換してレスポンス用に準備
        return UserRegisteredResult.from(savedUser);
    }
}
```

**ポイント:**

- 単一責任: ユーザー登録のビジネスロジックのみ
- トランザクション: @Transactional でデータ整合性保証
- 例外処理: ドメイン例外をそのままスロー（Global Handler で処理）

#### データフローの詳細

```
1. Command → Domain ValueObject (変換)
2. Domain ValueObject → Repository (重複チェック)
3. Plain Password → PasswordHash (ハッシュ化)
4. ValueObjects → User Domain (ファクトリメソッド)
5. User Domain → Repository → Database (永続化)
6. User Domain → DTO (変換)
```

## 🎨 設計パターンと原則

### 1. Command Query Responsibility Segregation (CQRS)

- **Command**: RegisterUserCommand（書き込み用）
- **Query**: UserRegisteredResult（読み込み用）

### 2. Factory パターン

```java
// ドメインオブジェクト生成
User newUser = User.register(email, username, passwordHash);

// DTO生成
UserRegisteredResult result = UserRegisteredResult.from(savedUser);
```

### 3. Repository パターン

```java
// ドメイン層でインターフェース定義
public interface UserRepository {
    Optional<User> findByEmail(Email email);
    User save(User user);
}
```

### 4. Value Object パターン

```java
// 型安全性とバリデーション
Email email = new Email("user@example.com");  // 自動バリデーション
Username username = new Username("john_doe");  // 自動正規化
```

## 🔄 完全なデータフロー図

```
HTTP Request (JSON)
       ↓
RegisterUserCommand (Command)
       ↓
Service Layer (Business Logic)
       ↓
┌─────────────────────────────────┐
│ 1. Command → ValueObject       │
│ 2. Duplicate Check (Repository) │
│ 3. Password Hashing             │
│ 4. Domain Model Creation        │
│ 5. Database Persistence         │
│ 6. Domain → DTO Conversion      │
└─────────────────────────────────┘
       ↓
UserRegisteredResult (DTO)
       ↓
HTTP Response (JSON)
```

## 🚀 実装の利点

### 1. **レイヤー分離**

- 各層が独立して変更可能
- テスタビリティの向上

### 2. **型安全性**

- Value Object による不正値の排除
- コンパイル時エラー検出

### 3. **セキュリティ**

- パスワードハッシュの自動化
- 機密情報の露出防止

### 4. **保守性**

- ビジネスルールの一元管理
- ドメインロジックの保護

## 🎯 実装時のチェックポイント

### Command クラス

- [ ] デフォルトコンストラクタの実装
- [ ] バリデーションアノテーション
- [ ] ドメインオブジェクト変換メソッド

### DTO クラス

- [ ] セキュリティ情報の除外
- [ ] ファクトリメソッドの実装
- [ ] 時刻変換の適切な処理

### Service クラス

- [ ] @Transactional アノテーション
- [ ] 重複チェックの実装
- [ ] 例外処理の適切な設計
- [ ] 処理フローのコメント記載

## まとめ

Spring Boot でのユーザー登録機能実装は、以下の順序で段階的に進めることで、保守性と安全性を両立できます：

1. **Command 設計**: 入力データの型安全性確保
2. **DTO 設計**: 出力データのセキュリティ配慮
3. **Service 実装**: ビジネスロジックの一元管理

この実装パターンにより、要件変更に強く、テスト可能で、セキュアなユーザー登録機能を構築できます。

## 参考資料

- [Domain-Driven Design: Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Spring Boot Reference Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Clean Architecture: A Craftsman's Guide to Software Structure and Design](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164)

---

この記事が Spring Boot でのユーザー登録機能実装の理解に役立てば幸いです！
