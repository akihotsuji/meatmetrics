# DDD におけるエンティティの二層分離：ドメインエンティティと JPA エンティティの責務分離

## はじめに

ドメイン駆動設計（DDD）を実践する際、「エンティティ」という用語が複数の文脈で使われることがあります。

- **ドメインエンティティ**: ビジネスロジックを持つドメイン層のオブジェクト
- **JPA エンティティ**: データベースとのマッピングを担うインフラ層のオブジェクト

本記事では、これら 2 つのエンティティを明確に分離し、それぞれの責務を適切に配置する実装パターンについて図解で解説します。

## 問題：責務が混在したエンティティ

### アンチパターンの構造

```mermaid
classDiagram
    class User {
        +String id
        +String email
        +LocalDateTime createdAt
        +canUpdateProfile() boolean
        +changeEmail(String) void
        +save()
        +findById() User
    }

    note for User "❌ 問題：責務が混在<br/>・ビジネスロジック<br/>・データ永続化<br/>・JPA注釈が同居"
```

### 問題点

1. **責務の混在**: ビジネスロジックとデータアクセスが同一クラス
2. **技術依存**: ドメインロジックが JPA 技術に依存
3. **テスト困難**: 単体テストでデータベース接続が必要

## 解決策：エンティティの二層分離

### アーキテクチャ全体図

```mermaid
graph TB
    subgraph "ドメイン層"
        DE["👑 ドメインエンティティ<br/>User"]
        VO["💎 値オブジェクト<br/>Email, UserId"]
        RI["📋 リポジトリIF<br/>UserRepository"]
    end

    subgraph "インフラ層"
        JE["🗄️ JPAエンティティ<br/>UserEntity"]
        MA["🔄 マッパー<br/>UserMapper"]
        RP["📊 リポジトリ実装<br/>UserRepositoryImpl"]
        JP["🔌 JPAリポジトリ<br/>UserJpaRepository"]
    end

    subgraph "データベース"
        DB["🗃️ PostgreSQL<br/>users テーブル"]
    end

    DE --> VO
    DE --> RI
    RI --> RP
    RP --> MA
    RP --> JP
    MA --> DE
    MA --> JE
    JP --> JE
    JP --> DB

    classDef domain fill:#e1f5fe
    classDef infra fill:#f3e5f5
    classDef db fill:#e8f5e8

    class DE,VO,RI domain
    class JE,MA,RP,JP infra
    class DB db
```

## 各コンポーネントの責務

### ドメイン層の責務

```mermaid
graph LR
    subgraph "ドメインエンティティ"
        BL["ビジネスロジック<br/>changeEmail()<br/>canUpdateProfile()"]
    end

    subgraph "値オブジェクト"
        VAL["値の検証<br/>不変性保証<br/>等価性比較"]
    end

    subgraph "リポジトリIF"
        CONTRACT["データアクセス<br/>契約定義"]
    end

    BL --> VAL
    BL --> CONTRACT
```

### インフラ層の責務

```mermaid
graph LR
    subgraph "JPAエンティティ"
        PERSIST["データ永続化<br/>テーブルマッピング<br/>JPA注釈"]
    end

    subgraph "マッパー"
        CONVERT["オブジェクト変換<br/>Domain ⇔ JPA<br/>データ整合性"]
    end

    subgraph "リポジトリ実装"
        IMPL["インターフェース実装<br/>クエリ実行<br/>トランザクション"]
    end

    CONVERT --> PERSIST
    IMPL --> CONVERT
```

## 実装のポイント

### 1. ドメインエンティティ（純粋なビジネスロジック）

```java
public class User {
    private final UserId id;
    private Email email;

    // ✅ ビジネスルールのみに集中
    public void changeEmail(Email newEmail) {
        if (this.email.equals(newEmail)) {
            throw new DomainException("同じメールアドレスには変更できません");
        }
        this.email = newEmail;
    }
}
```

### 2. 値オブジェクト（検証とカプセル化）

```java
public class Email {
    private final String value;

    public Email(String value) {
        // ✅ 作成時に必ず検証
        validateFormat(value);
        this.value = normalize(value);
    }
}
```

### 3. マッパー（変換の責務分離）

```java
@Component
public class UserMapper {
    // ✅ 双方向変換を担当
    public UserEntity toEntity(User user) { /* ... */ }
    public User toDomain(UserEntity entity) { /* ... */ }
}
```

## データの流れ

### ユーザー登録のシーケンス

```mermaid
sequenceDiagram
    participant App as アプリケーション
    participant Domain as ドメインエンティティ
    participant Repo as リポジトリ実装
    participant Mapper as マッパー
    participant JPA as JPAエンティティ
    participant DB as データベース

    App->>Domain: new User(id, email)
    Domain->>Domain: ビジネスルール検証
    App->>Repo: save(user)
    Repo->>Mapper: toEntity(user)
    Mapper->>JPA: new UserEntity(...)
    Repo->>DB: insert into users
    DB-->>Repo: OK
    Repo-->>App: 完了
```

### 検索時のデータ変換

```mermaid
sequenceDiagram
    participant App as アプリケーション
    participant Repo as リポジトリ実装
    participant Mapper as マッパー
    participant JPA as JPAエンティティ
    participant Domain as ドメインエンティティ

    App->>Repo: findByEmail(email)
    Repo->>JPA: JPAリポジトリ検索
    JPA-->>Repo: UserEntity
    Repo->>Mapper: toDomain(entity)
    Mapper->>Domain: new User(id, email)
    Domain-->>Mapper: User
    Mapper-->>Repo: User
    Repo-->>App: User
```

## テスト戦略

### 各層のテスト方針

```mermaid
graph TB
    subgraph "テストピラミッド"
        E2E["🌐 E2Eテスト<br/>（少数）"]
        INT["🔗 統合テスト<br/>（中程度）"]
        UNIT["⚡ 単体テスト<br/>（多数・高速）"]
    end

    subgraph "対象"
        DOM["ドメインエンティティ"]
        REPO["リポジトリ実装"]
        APP["アプリケーションサービス"]
    end

    UNIT --> DOM
    INT --> REPO
    E2E --> APP

    classDef test fill:#fff2cc
    classDef target fill:#d5e8d4

    class E2E,INT,UNIT test
    class DOM,REPO,APP target
```

詳細なテスト実装については、別記事「DDD アプリケーションのテスト戦略：モックテストと Testcontainers による統合テスト」をご参照ください。

## この分離パターンの価値

### ✅ メリット

```mermaid
mindmap
  root((エンティティ分離))
    責務の明確化
      ビジネスロジック純粋性
      技術詳細の隔離
    保守性向上
      変更影響の局所化
      コード理解容易性
    テスト品質
      単体テスト高速化
      モック化簡単
    拡張性
      技術変更対応
      新機能追加容易
```

### ⚠️ 注意点

- **小規模プロジェクト**: 設計の複雑さが開発効率を下げる可能性
- **チーム習熟度**: DDD 理解不足による設計の乱れ
- **変換コスト**: マッパーによる軽微なパフォーマンス影響

## まとめ

DDD におけるエンティティの二層分離は、**責務の明確な分離**により以下を実現します：

1. **ドメインロジックの純粋性保持**
2. **技術変更への高い耐性**
3. **効率的なテスト戦略**

プロジェクトの規模と要件に応じて、適切なレベルで導入することで、保守性と拡張性に優れたシステムを構築できます。

## 参考資料

- [ドメイン駆動設計 エリック・エヴァンス](https://www.amazon.co.jp/dp/4798121967)
- [実践ドメイン駆動設計 ヴァーン・ヴァーノン](https://www.amazon.co.jp/dp/479813161X)
- [Spring Data JPA Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
